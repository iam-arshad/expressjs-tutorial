create a repo in github and clone it locally
git clone https://github.com/iam-arshad/expressjs-tutorial.git

C:\Users\arshad\VS code Projects\expressjs-tutorial>npm init

>npm i expressjs nodemon

create a file src/index.js:
console.log("abc");

Add these two commands under scripts in package.json:
"start":"node ./src/index.js",
"start:dev":"nodemon ./src/index.js"

>npm run start:dev
will start our server




2.get request
Install postman, an API platform for building and using APIs.
Write the code for the get request at /todos endpoint as mentioned in the src/index.js
>npm run dev:start
Postman:GET http://localhost:3000/todos
hit this api in postman, and you will get the data as response.




3.post request
Write the code for the post request at /todos endpoint as mentioned in the src/index.js
Postman: body/raw/json
{"title":"review pull requests","description":"review pull requests on github","completed":false}

will get the response of same todo with the todo id,
{
    "id": 3,
    "title": "review pull requests",
    "description": "review pull requests on github",
    "completed": false
}




4a.Query params
To filter the data on any endpoint
ex:
http://localhost:3000/todos?id=1
http://localhost:3000/todos?id=1&title=abc
>req.query
//{id:1,title:abc}
The code to handle those query params will be in the same endpoint(here http://localhost:3000/todos)




4b.url(route) params
to identify a specific resource
ex:
http://localhost:3000/todos/1
http://localhost:3000/todos/2
>req.params


5a.PUT request
This request is to update/replace the entire resource(a new resource can also be created)
As we have 2 todos in our data.If i want to update the 2nd todo
Postman:
PUT: http://localhost:3000/todos/2
Body/raw/JSON: {"title":"review pull requests","description":"review pull requests on github","completed":false}
When we hit this api,then the 2nd todo will be updated with the new data.


5b. PATCH request
This is to partially update the resource data.
If we want to update the todo status completed as true,
PATCH: http://localhost:3000/todos/1
Body/raw/JSON: {"completed":false}
When we hit this api,then the 1st todo will be updated with the new completed status as true.


6.DELETE request
To delete a resource
To delete a todo from the todos data,
DELETE: http://localhost:3000/todos/1
When we hit this api,then the 1st todo will be deleted and will return the deleted todo.



7.Common(most used) request and response object methods
Request Object (req):
req.params: An object containing route parameters, e.g., /users/:id will be available as req.params.id.
req.query: An object containing the parsed query parameters from the URL.
req.body: An object containing the parsed request body when using a middleware like body-parser to handle JSON, URL-encoded, or multi-part form data.
req.cookies: An object containing cookies sent by the client.
req.headers: An object containing the HTTP headers sent by the client.
req.method: The HTTP method used in the request (GET, POST, PUT, DELETE, etc.).
req.url: The URL of the request.
req.path: The path of the request (excluding query parameters).
req.protocol: The request protocol (http or https).
req.get(headerName): Get the value of an HTTP header.
...

Response Object (res):
res.send(data): Send a response with the specified data to the client. The data can be a string, object, or buffer.
res.json(data): Send a JSON response to the client.
res.status(code): Set the status code of the response.
res.redirect(path): Redirect the client to the specified path.
res.render(view, data): Render a view template and send it as a response to the client.
res.sendFile(path): Send a file as the response to the client.
res.set(headerName, value): Set an HTTP header in the response.
res.cookie(name, value, options): Set a cookie in the response.
res.clearCookie(name, options): Clear a cookie in the response.
res.locals: An object to pass data to the view template engine.
res.end(): End the response process.
Note: can also be chained like res.status(201).send("ok");



8. Middlewares
Middlewares in Express are functions that have access to the request (req) and response (res) objects and the next function.
They enable you to perform various tasks in between processing a request and sending a response.
Middlewares are used for tasks such as authentication, logging, error handling, and parsing the request body.
Each middleware can perform its action and then choose to either pass the request to the next middleware in the chain or respond to the client directly.

A middleware is defined using the app.use() method
Even the route handler is a middleware.
Middleware can be custom defined functions,3rd party packages like body-parser, morgan, cors,helmet,...

a)Middleware for all the routes:
app.use((req,res,next)=>{...;next();})

b)Middleware for a specific route
app.get("/todos",(req,res,next)=>{..;next();},(req,res)=>{....})
Here there is only 1 middleware but we can chain many middlewares(in which each calls the other using next() until it reaches the route handler)

Execute code on every request:
1.Middlewares defined using app.use() are executed on every incoming request regardless of the request method (GET, POST, etc.) or the URL.
2.Order of Middleware Execution:
in the order they are declared in your application. So, if you have multiple middlewares defined, the first middleware gets executed first, then the second, and so on.
3.Manipulate Request and Response:
Middlewares have access to both the req and res objects. You can read and modify request data, set response headers, and perform other operations before sending the final response.
4.Handle Errors:
You can define error-handling middleware functions using four parameters (err, req, res, next). These middleware functions are called whenever there is an error during the request-response cycle.
5.Terminate Request-Response Cycle:
A middleware can also decide to terminate the request-response cycle by responding to the client directly without calling the next() function.



9. Express Router
In our tutorial upto now we have only todos section, but in the furthur sections we need to have database connectivity and so on.For that, if we write all our code in index.js, it will be difficult later on for debugging,updating,....
you can organize your routes into separate modules and then use the Express Router to manage these routes. This approach makes your code more modular and easier to maintain as your application grows.

create new directories & files in src as routes/todos/todos.js and move all the code related to the todos.
modify the code from app(Express instance) to router(Router instance)
export that router from todos.js and import it in src/index,js and mount it as a middleware at the prefix "/todos"

Now our enpoints will be accessible at the base path of http://localhost:3000/todos/
Ex:
GET: http://localhost:3000/todos/todos
GET: http://localhost:3000/todos/todos?id=1
GET: http://localhost:3000/todos/todos/1
POST: http://localhost:3000/todos/todos
PUT:http://localhost:3000/todos/todos/1
PATCH: http://localhost:3000/todos/todos/1
DELETE: http://localhost:3000/todos/todos/1
where the first "todos" is the prefix and the second "todos" is the endpoint, we will fix them in the next chapter


10. Prefixes
To modify our endpoint paths, we have to do that in the todos router.
Now our enpoints will be accessible at the base path of http://localhost:3000/todos/
Ex:
GET: http://localhost:3000/todos
GET: http://localhost:3000/todos?id=1
GET: http://localhost:3000/todos/1
POST: http://localhost:3000/todos
PUT:http://localhost:3000/todos/1
PATCH: http://localhost:3000/todos/1
DELETE: http://localhost:3000/todos/1

We can also prefix like versions of api,...
ex:
For http://localhost:3000/api/v1/todos/
use the middleware app.use("/api/v1/todos",todosRouter);


11.cookies
Cookies are small pieces of data that a server --->user's web browser(stores them), 
Cookies(are sent back to) --->server with each subsequent request, allowing the server to recognize the user or store small amounts of user-specific information like
User Preferences: Store user preferences, such as language preference, theme, or display settings.
Remember Me: For "Remember Me" functionality during login, you can store a persistent session identifier in a cookie.
Authentication Tokens: Store short-lived authentication tokens (such as JWTs) to maintain user sessions across requests.
Tracking and Analytics: Store tracking information for analytics and user behavior analysis.
Shopping Cart: Store minimal cart information for e-commerce sites.
Personalization: Store data used to personalize user experiences, like recently viewed items or recommended content.

>npm install cookie-parser
To set a cookie:(res obj as we are creating in server side)
res.cookie('username', 'john', { maxAge: 900000, httpOnly: true })
To get a cookie:(req obj as we are getting it from client side)
req.cookies.username

updated the index.js file with the code related to cookies
Now test the endpoints
http://localhost:3000/set-cookie
check the cookies now with the name "username" has the value of 
username=john; Path=/; HttpOnly; Expires=Tue, 08 Aug 2023 02:13:22 GMT;

http://localhost:3000/get-cookie
will get the username from cookies(if it has not expired)




12.Sessions
Cookies are limited to 4KB in size and lives in client side(prone to attacks).
Sessions are a way to store user-specific data on the server side and associate it with a particular user. A session usually involves creating a unique session ID for each user, and this ID is stored in a cookie on the user's browser.

What to store in sessions:
User Authentication State: Store whether a user is logged in or not.
User Profile Data: Store user-specific information that might be required across multiple pages, such as username, email, and user role.
Sensitive Data: Store sensitive data that should not be exposed to the client, like server-side generated tokens or API keys.
Temporary Data: Store temporary data that needs to be preserved across requests, like form data that spans multiple pages.
Access Control Information: Store information about user roles and permissions.
Cart and Order Data: Store comprehensive cart information, order history, and other e-commerce related data.

In this example, I will remove the code from the previous chapter of cookies and will create a login route which uses both cookies(not to store sensitive data) and sessions.
>npm i express-session
Make the code changes according to this commit and temporary
http://localhost:3000/auth/login
Body/raw/JSON:
{
    "username":"user1",
    "password":"password1"
}
and then try
http://localhost:3000/auth/profile